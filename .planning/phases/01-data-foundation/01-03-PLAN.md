---
phase: 01-data-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/actions/spools.ts
  - src/lib/validations.ts
autonomous: true

must_haves:
  truths:
    - "Server action can create a new spool with all required fields and store it in SQLite"
    - "Server action can retrieve all spools from the database"
    - "Server action can retrieve a single spool by ID"
    - "Server action can update any field on an existing spool"
    - "Server action can delete a spool by ID"
    - "Input validation prevents saving spools with missing required fields"
  artifacts:
    - path: "src/actions/spools.ts"
      provides: "Server actions for spool CRUD operations"
      exports: ["createSpool", "getSpools", "getSpool", "updateSpool", "deleteSpool"]
    - path: "src/lib/validations.ts"
      provides: "Zod validation schemas for spool input"
      contains: "spoolSchema"
  key_links:
    - from: "src/actions/spools.ts"
      to: "src/db/schema.ts"
      via: "drizzle query using spools table"
      pattern: "import.*spools.*from.*schema"
    - from: "src/actions/spools.ts"
      to: "src/lib/db.ts"
      via: "database connection import"
      pattern: "import.*db.*from.*lib/db"
    - from: "src/actions/spools.ts"
      to: "src/lib/validations.ts"
      via: "validation schema import"
      pattern: "import.*spoolSchema.*from.*validations"
---

<objective>
Create server actions for spool CRUD operations with input validation.

Purpose: Provides the data access layer that Phase 2 (Inventory Management) will connect to forms. Server actions give type-safe, server-side data operations callable from React components.
Output: Five server actions (create, list, get, update, delete) with Zod validation.
</objective>

<execution_context>
@/Users/monkey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/monkey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-CONTEXT.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for spool input</name>
  <files>src/lib/validations.ts</files>
  <action>
    Install zod: `npm install zod`.

    Create `src/lib/validations.ts` with validation schemas for spool operations.

    Define `createSpoolSchema` using Zod:
    - brand: z.string().min(1, "Brand is required").max(100)
    - material: z.string().min(1, "Material is required").max(50)
    - modifier: z.string().max(50).nullable().optional() (transforms undefined to null)
    - colorName: z.string().min(1, "Color name is required").max(100)
    - colorHex: z.string().regex(/^#[0-9A-Fa-f]{6}$/, "Must be a valid hex color")
    - status: z.enum(["sealed", "in_use", "empty"]).default("sealed")
    - initialWeight: z.number().int().positive().default(1000)
    - purchaseDate: z.string().nullable().optional() (ISO date string, transforms undefined to null)
    - price: z.number().positive().nullable().optional() (transforms undefined to null)
    - notes: z.string().max(500).nullable().optional() (transforms undefined to null)

    Define `updateSpoolSchema` as `createSpoolSchema.partial()` â€” all fields optional for partial updates.

    Export both schemas and infer types:
    ```typescript
    export type CreateSpoolInput = z.infer<typeof createSpoolSchema>;
    export type UpdateSpoolInput = z.infer<typeof updateSpoolSchema>;
    ```

    Also export a `SPOOL_STATUSES` constant array: `["sealed", "in_use", "empty"] as const` and type `SpoolStatus`.
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify schemas validate correctly: a minimal valid input (brand, material, colorName, colorHex) should pass createSpoolSchema, and an empty object should fail. Test with a quick inline assertion or console.log if needed.
  </verify>
  <done>createSpoolSchema and updateSpoolSchema exported. CreateSpoolInput and UpdateSpoolInput types exported. SPOOL_STATUSES constant exported. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for spool CRUD</name>
  <files>src/actions/spools.ts</files>
  <action>
    Create `src/actions/spools.ts` with "use server" directive at the top.

    Import db from "@/lib/db", spools table from "@/db/schema", validation schemas from "@/lib/validations", and drizzle operators (eq) from "drizzle-orm".

    Implement these server actions:

    **createSpool(input: CreateSpoolInput)**
    - Validate input with createSpoolSchema.parse()
    - Generate UUID for id (crypto.randomUUID())
    - Insert into spools table via db.insert(spools).values(...)
    - Set createdAt and updatedAt to new Date().toISOString()
    - Return { success: true, spool } with the created record
    - Wrap in try/catch, return { success: false, error: string } on failure

    **getSpools()**
    - Select all from spools table
    - Order by createdAt descending (newest first)
    - Return { success: true, spools: Spool[] }

    **getSpool(id: string)**
    - Select from spools where id matches
    - Return { success: true, spool } or { success: false, error: "Spool not found" }

    **updateSpool(id: string, input: UpdateSpoolInput)**
    - Validate input with updateSpoolSchema.parse()
    - Update spools table where id matches, set updatedAt to now
    - Return { success: true, spool } with updated record
    - Return { success: false, error } if spool not found or validation fails

    **deleteSpool(id: string)**
    - Delete from spools where id matches
    - Return { success: true } on success
    - Return { success: false, error } if not found

    Use revalidatePath("/") after create, update, and delete operations to ensure Next.js cache invalidation.

    All return types should use a discriminated union pattern:
    ```typescript
    type ActionResult<T> = { success: true } & T | { success: false; error: string };
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all types resolve correctly. Verify the file exports all 5 functions. Create a quick smoke test: write a temporary script or use the Next.js dev server to call createSpool with test data, then getSpools to confirm it returns the created spool, then deleteSpool to clean up. Alternatively, verify by importing and checking types compile.
  </verify>
  <done>Five server actions exported: createSpool, getSpools, getSpool, updateSpool, deleteSpool. All use Zod validation. All return discriminated union results. revalidatePath called on mutations. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with all new files
2. `src/lib/validations.ts` exports createSpoolSchema, updateSpoolSchema, and type definitions
3. `src/actions/spools.ts` exports all 5 CRUD server actions
4. Server actions import from schema.ts and db.ts correctly
5. A test create+read+delete cycle works (manual or scripted verification)
</verification>

<success_criteria>
- All 5 spool CRUD server actions work end-to-end with SQLite
- Input validation catches missing required fields
- Proper error handling with discriminated union return types
- Cache invalidation via revalidatePath on mutations
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-03-SUMMARY.md`
</output>
